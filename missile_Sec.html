<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>미사일 피하기 게임(모바일)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body { height: 100%; margin:0; padding:0; overflow: hidden; touch-action: none;}
    body { background: #333; margin:0; position:relative; height:100vh; touch-action: none;}
    #game-container { position:fixed; top:0; left:0; width:100vw; height:100vh; margin:0; padding:0; touch-action: none;}
    canvas { background: #fff; display: block; width: 100vw; height: 100vh; border-radius: 0; touch-action: none;}
    #result {
      position: absolute;
      left: 50%; top: 36%;
      transform: translate(-50%, -50%);
      font-size: 7vw;
      color: #d32f2f;
      font-family: 'Consolas', 'Arial';
      font-weight: bold;
      background: rgba(255,255,255,0.88);
      padding: 3vw 7vw 1vw 7vw;
      border-radius: 5vw;
      display: none;
      z-index: 2;
      text-align: center;
      box-shadow: 0 2px 16px rgba(0,0,0,0.13);
      min-width: 36vw;
      pointer-events:none;
    }
    #restart {
      position: absolute;
      left: 50%; top: 61%;
      transform: translate(-50%, -50%);
      font-size: 4.3vw;
      color: #555;
      font-family: 'Consolas', 'Arial';
      background: rgba(255,255,255,0.93);
      padding: 2.6vw 7vw;
      border-radius: 4vw;
      display: none;
      z-index: 3;
      text-align: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.10);
      cursor:pointer;
      user-select: none;
    }
    #joystick {
      position: fixed;
      left: 0; top: 0;
      width: 92px; height: 92px;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      user-select: none;
      background: transparent;
      touch-action: none;
      transition: opacity 0.09s;
      display: block; /* 항상 block */
    }
    #joystick.visible {
      opacity: 0.98;
      pointer-events: auto;
    }
    .joystick-bg {
      position: absolute; left:0; top:0;
      width: 92px; height: 92px;
      border-radius: 50%;
      background: #ddd;
      opacity:0.35;
      border: 2.5px solid #bbb;
      pointer-events: none;
    }
    .joystick-knob {
      position: absolute; left:31px; top:31px;
      width: 30px; height:30px;
      background:#1976d2;
      border-radius: 50%;
      box-shadow: 0 2px 8px #2222;
      border: 2px solid #1976d2;
      touch-action: none;
      pointer-events: none;
    }
    #settings-btn {
      position: absolute;
      left: 2vw; top: 2vw;
      width: 11vw; height: 11vw;
      min-width: 42px; min-height: 42px;
      max-width: 62px; max-height: 62px;
      z-index: 1100;
      background: rgba(255,255,255,0.92);
      border-radius: 50%;
      box-shadow: 0 1px 8px #1113;
      display: flex; align-items: center; justify-content: center;
      border: none;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
    }
    #settings-btn svg {
      width: 67%; height: 67%;
      display: block;
      fill: #1976d2;
    }
    #settings-panel {
      position: fixed;
      left: 50%; top: 50%;
      transform: translate(-50%,-50%);
      width: 82vw; max-width: 340px;
      background: rgba(255,255,255,0.98);
      border-radius: 4vw;
      box-shadow: 0 2px 20px #2225;
      z-index: 1200;
      padding: 6vw 5vw 5vw 5vw;
      display: none;
      text-align: center;
    }
    #settings-title {
      font-size: 5.2vw;
      font-weight: bold;
      color: #1976d2;
      margin-bottom: 5vw;
      letter-spacing: -0.6vw;
      text-align: left;
      padding-left: 1vw;
    }
    #close-settings {
      position: absolute;
      right: 5vw; top: 4vw;
      font-size: 6vw;
      font-family: Arial, sans-serif;
      color: #999;
      background: none;
      border: none;
      z-index: 1230;
      cursor: pointer;
      user-select: none;
      width: 11vw; height: 11vw; min-width:42px; min-height:42px;
      display: flex; align-items:center; justify-content: center;
    }
    #sensitivity-slider {
      width: 100%;
      accent-color: #1976d2;
      margin-bottom: 2vw;
    }
    #sensitivity-value {
      display: inline-block;
      min-width: 40px;
      text-align: center;
      color: #1976d2;
      font-weight: bold;
      font-size: 4.4vw;
      margin-bottom: 1vw;
    }
    #countdown {
      position: fixed;
      left: 50%; top: 44%;
      transform: translate(-50%, -50%);
      font-size: 14vw;
      color: #1976d2;
      font-family: 'Consolas', 'Arial', sans-serif;
      font-weight: bold;
      background: rgba(255,255,255,0.92);
      padding: 4vw 10vw 3vw 10vw;
      border-radius: 5vw;
      display: none;
      z-index: 2001;
      text-align: center;
      box-shadow: 0 2px 18px rgba(0,0,0,0.16);
      user-select: none;
      pointer-events:none;
      letter-spacing: 2vw;
    }
    @media (max-width:400px) {
      #settings-panel { width: 96vw; max-width: none; font-size: 5vw;}
      #settings-title, #sensitivity-value { font-size: 6vw; }
      #close-settings { font-size: 8vw; }
      #countdown { font-size: 18vw; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game"></canvas>
    <div id="result"></div>
    <div id="restart">터치해서<br>시작하세요.</div>
    <button id="settings-btn" aria-label="설정">
      <!-- 톱니 SVG -->
      <svg viewBox="0 0 24 24"><path d="M19.14,12.94c0-.32,0-.64,0-1s0-.65,0-1l2.11-1.65a.47.47,0,0,0,.11-.61l-2-3.46a.47.47,0,0,0-.57-.22l-2.49,1a7.09,7.09,0,0,0-1.74-1l-.38-2.65A.47.47,0,0,0,13,2h-4a.47.47,0,0,0-.46.39l-.38,2.65a7.09,7.09,0,0,0-1.74,1l-2.49-1a.47.47,0,0,0-.57.22l-2,3.46a.47.47,0,0,0,.11.61L4.86,10c0,.32,0,.64,0,1s0,.65,0,1L2.75,13.65a.47.47,0,0,0-.11.61l2,3.46a.47.47,0,0,0,.57.22l2.49-1a7.09,7.09,0,0,0,1.74,1l.38,2.65A.47.47,0,0,0,9,22h4a.47.47,0,0,0,.46-.39l.38-2.65a7.09,7.09,0,0,0,1.74-1l2.49,1a.47.47,0,0,0,.57-.22l2-3.46a.47.47,0,0,0-.11-.61ZM12,15.5A3.5,3.5,0,1,1,15.5,12,3.5,3.5,0,0,1,12,15.5Z"/></svg>
    </button>
    <div id="settings-panel">
      <button id="close-settings" aria-label="닫기">✕</button>
      <div id="settings-title">설정</div>
      <label for="sensitivity-slider" style="font-weight:bold;">조작 감도(민감도)</label>
      <input type="range" id="sensitivity-slider" min="10" max="100" value="50" step="1">
      <div id="sensitivity-value">50</div>
    </div>
    <div id="joystick">
      <div class="joystick-bg"></div>
      <div class="joystick-knob"></div>
    </div>
    <div id="countdown"></div>
  </div>
  <script>
    // ------------------ 옵션 설정
    let sensitivity = 0.5;
    let isPaused = false;
    let waitingForResume = false;

    // ------------------ 감도 슬라이더
    const slider = document.getElementById('sensitivity-slider');
    const sValue = document.getElementById('sensitivity-value');
    slider.addEventListener('input', function(e) {
      sensitivity = slider.value / 100;
      sValue.textContent = slider.value;
    }, false);

    // ------------------ 설정 패널, 톱니, 닫기, 카운트다운
    const settingsBtn = document.getElementById('settings-btn');
    const settingsPanel = document.getElementById('settings-panel');
    const closeSettings = document.getElementById('close-settings');
    const countdownDiv = document.getElementById('countdown');

    function showSettings() {
      isPaused = true;
      waitingForResume = false;
      settingsPanel.style.display = 'block';
      countdownDiv.style.display = 'none';
    }
    function hideSettingsAndCountdown() {
      settingsPanel.style.display = 'none';
      countdownDiv.style.display = 'none';
    }
    function closeSettingsPanel() {
      settingsPanel.style.display = 'none';
      startResumeCountdown(3);
    }

    // 터치/클릭 이벤트 위임
    settingsBtn.addEventListener('touchstart', function(e){ e.preventDefault(); showSettings(); }, {passive:false});
    settingsBtn.addEventListener('click', function(e){ e.preventDefault(); showSettings(); }, false);
    closeSettings.addEventListener('touchstart', function(e){ e.preventDefault(); closeSettingsPanel(); }, {passive:false});
    closeSettings.addEventListener('click', function(e){ e.preventDefault(); closeSettingsPanel(); }, false);

    // 포커스 활성화 방지
    settingsPanel.addEventListener('touchmove', function(e){ e.stopPropagation(); }, false);
    slider.addEventListener('touchmove', function(e){ e.stopPropagation(); }, false);

    function startResumeCountdown(n) {
      waitingForResume = true;
      isPaused = true;
      countdownDiv.textContent = n;
      countdownDiv.style.display = 'block';
      let count = n;
      function nextCount() {
        if (count > 1) {
          setTimeout(()=>{
            count--;
            countdownDiv.textContent = count;
            nextCount();
          }, 800);
        } else {
          setTimeout(()=>{
            countdownDiv.style.display = 'none';
            isPaused = false;
            waitingForResume = false;
          }, 800);
        }
      }
      nextCount();
    }

    // ------------------ 게임 관련
    const container = document.getElementById('game-container');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const resultDiv = document.getElementById('result');
    const restartDiv = document.getElementById('restart');
    const joystick = document.getElementById('joystick');
    const knob = joystick.querySelector('.joystick-knob');

    const player = {
      x: 0, y: 0, r: 30, color: '#1976d2', speed: 5
    };
    const missiles = [];

    let joystickActive = false, joyDX = 0, joyDY = 0;
    let baseX=0, baseY=0, joyRadius=46, knobRadius=15;

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);
      updatePlayerStats(true);
    }

    function updatePlayerStats(forceCenter) {
      const w = canvas.width / (window.devicePixelRatio||1);
      const h = canvas.height / (window.devicePixelRatio||1);
      player.r = Math.round(Math.max(w,h)/19.5) || 30;
      player.speed = Math.max(w,h)/110 || 5;
      if (
        isNaN(player.x) || isNaN(player.y) || player.x <= 0 || player.y <= 0 ||
        player.x < player.r || player.x > w - player.r ||
        player.y < player.r || player.y > h - player.r ||
        forceCenter
      ) {
        player.x = w/2;
        player.y = h/2;
      }
    }

    container.addEventListener('touchstart', function(ev) {
      if (gameOver || isPaused || waitingForResume) return;
      if (ev.touches.length > 1) return;
      const t = ev.touches[0];
      joystick.classList.add('visible');
      requestAnimationFrame(() => {
        joyRadius = joystick.offsetWidth/2;
        knobRadius = knob.offsetWidth/2;
        baseX = t.clientX;
        baseY = t.clientY;
        joystick.style.left = (baseX-joyRadius) + "px";
        joystick.style.top  = (baseY-joyRadius) + "px";
        knob.style.left = (joyRadius - knobRadius) + "px";
        knob.style.top  = (joyRadius - knobRadius) + "px";
        joystickActive = true;
        joyDX = 0; joyDY = 0;
      });
      ev.preventDefault();
    }, {passive:false});

    container.addEventListener('touchmove', function(ev) {
      if(!joystickActive || isPaused || waitingForResume) return;
      if (ev.touches.length === 0) return;
      const t = ev.touches[0];
      let dx = t.clientX - baseX;
      let dy = t.clientY - baseY;
      requestAnimationFrame(() => {
        let dist = Math.sqrt(dx*dx + dy*dy);
        let maxDist = joyRadius - knobRadius;
        if(dist > maxDist) {
          dx = dx * maxDist / dist;
          dy = dy * maxDist / dist;
        }
        knob.style.left = (joyRadius + dx - knobRadius) + "px";
        knob.style.top  = (joyRadius + dy - knobRadius) + "px";
        joyDX = (dx / maxDist) * sensitivity;
        joyDY = (dy / maxDist) * sensitivity;
      });
      ev.preventDefault();
    }, {passive:false});

    container.addEventListener('touchend', function(ev) {
      joystickActive = false;
      joyDX = 0; joyDY = 0;
      joystick.classList.remove('visible');
      ev.preventDefault();
    }, {passive:false});

    function spawnMissile() {
      const w = canvas.width / (window.devicePixelRatio||1);
      const h = canvas.height / (window.devicePixelRatio||1);
      const edge = Math.floor(Math.random() * 4);
      let x, y, dx, dy;
      const missileSpeed = Math.max(w,h)/160 + Math.random() * 1.5;
      const mSize = Math.max(w,h)/28 + Math.random() * 8;
      if (edge === 0) { x = Math.random() * w; y = 0; }
      else if (edge === 1) { x = Math.random() * w; y = h; }
      else if (edge === 2) { x = 0; y = Math.random() * h; }
      else { x = w; y = Math.random() * h; }
      const angle = Math.atan2(player.y - y, player.x - x);
      dx = Math.cos(angle) * missileSpeed;
      dy = Math.sin(angle) * missileSpeed;
      missiles.push({ x, y, dx, dy, r: mSize, color: '#f44336' });
    }

    let missileInterval = 900;
    let lastMissileTime = 0;
    let startTime, survivedSec = 0, gameOver = false;

    function checkCollision(a, b) {
      const dist = Math.hypot(a.x - b.x, a.y - b.y);
      return dist < (a.r + b.r);
    }

    function startGame() {
      resizeCanvas();
      updatePlayerStats(true);
      const w = canvas.width / (window.devicePixelRatio||1);
      const h = canvas.height / (window.devicePixelRatio||1);
      player.x = w/2;
      player.y = h/2;
      missiles.length = 0;
      gameOver = false;
      startTime = Date.now();
      survivedSec = 0;
      resultDiv.style.display = 'none';
      restartDiv.style.display = 'none';
      missileInterval = 900;
      joystick.classList.remove('visible');
      isPaused = false;
      waitingForResume = false;
      requestAnimationFrame(gameLoop);
    }

    function gameLoop() {
      const w = canvas.width / (window.devicePixelRatio||1);
      const h = canvas.height / (window.devicePixelRatio||1);
      updatePlayerStats();

      // -------- 멈춤일 때 화면만 그리되, 모든 움직임/시간/미사일 생성 멈춤
      if (isPaused || waitingForResume) {
        // 배경과 오브젝트 그리기(멈춘 상태)
        ctx.clearRect(0, 0, w, h);
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
        ctx.fillStyle = player.color;
        ctx.shadowColor = '#90caf9';
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.closePath();
        ctx.shadowBlur = 0;
        for (let i = missiles.length - 1; i >= 0; i--) {
          const m = missiles[i];
          ctx.beginPath();
          ctx.arc(m.x, m.y, m.r, 0, Math.PI * 2);
          ctx.fillStyle = m.color;
          ctx.fill();
          ctx.closePath();
        }
        // 시간(생존 초) 표시
        ctx.save();
        ctx.font = "bold " + Math.round(w/18) + "px Consolas, Arial";
        ctx.fillStyle = "#1976d2";
        ctx.textAlign = "right";
        ctx.fillText(survivedSec.toFixed(1) + " Sec", w - 18, 42);
        ctx.restore();

        requestAnimationFrame(gameLoop);
        return;
      }

      // -------- 실제 게임진행 (움직임/시간/미사일)
      if (!gameOver) {
        survivedSec = (Date.now() - startTime) / 1000;
      }

      ctx.clearRect(0, 0, w, h);

      // 조이스틱 이동값 즉각 반영
      let dx = joyDX;
      let dy = joyDY;
      if (dx !== 0 || dy !== 0) {
        let len = Math.sqrt(dx*dx + dy*dy);
        if(len > 1) { dx /= len; dy /= len; }
        player.x += player.speed * dx;
        player.y += player.speed * dy;
        // 경계 체크
        if (player.x - player.r < 0) player.x = player.r;
        if (player.x + player.r > w) player.x = w - player.r;
        if (player.y - player.r < 0) player.y = player.r;
        if (player.y + player.r > h) player.y = h - player.r;
      }

      if (
        isNaN(player.x) || isNaN(player.y) || isNaN(player.r) ||
        player.x <= 0 || player.y <= 0 ||
        player.r <= 0
      ) {
        updatePlayerStats(true);
      }

      // 플레이어 그리기
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
      ctx.fillStyle = player.color;
      ctx.shadowColor = '#90caf9';
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.closePath();
      ctx.shadowBlur = 0;

      // 미사일 그리기 및 이동
      for (let i = missiles.length - 1; i >= 0; i--) {
        const m = missiles[i];
        m.x += m.dx;
        m.y += m.dy;
        ctx.beginPath();
        ctx.arc(m.x, m.y, m.r, 0, Math.PI * 2);
        ctx.fillStyle = m.color;
        ctx.fill();
        ctx.closePath();

        if (checkCollision(player, m)) {
          gameOver = true;
        }
        if (
          m.x < -40 || m.x > w + 40 ||
          m.y < -40 || m.y > h + 40
        ) {
          missiles.splice(i, 1);
        }
      }

      // 미사일 추가 (점점 빨라짐)
      const now = Date.now();
      if (now - lastMissileTime > missileInterval && !gameOver) {
        spawnMissile();
        lastMissileTime = now;
        if (missileInterval > 450) missileInterval -= 8;
      }

      // 생존 시간 표시
      ctx.save();
      ctx.font = "bold " + Math.round(w/18) + "px Consolas, Arial";
      ctx.fillStyle = "#1976d2";
      ctx.textAlign = "right";
      ctx.fillText(survivedSec.toFixed(1) + " Sec", w - 18, 42);
      ctx.restore();

      // 게임 오버 처리
      if (gameOver) {
        resultDiv.textContent = survivedSec.toFixed(1) + ' Sec';
        resultDiv.style.display = 'block';
        restartDiv.style.display = 'block';
        joystick.classList.remove('visible');
        // 터치로 재시작
        container.ontouchstart = function(ev) {
          if (ev.touches.length > 1) return;
          restartDiv.style.display = 'none';
          startGame();
          ev.preventDefault();
        };
        return;
      }
      requestAnimationFrame(gameLoop);
    }

    // 최초 시작
    function initialStart() {
      resizeCanvas();
      updatePlayerStats(true);
      resultDiv.textContent = '';
      restartDiv.style.display = 'block';
      resultDiv.style.display = 'none';
      restartDiv.innerHTML = '터치해서<br>시작하세요.';
      container.ontouchstart = function(ev) {
        if (ev.touches.length > 1) return;
        restartDiv.style.display = 'none';
        startGame();
        ev.preventDefault();
      };
    }

    initialStart();
    resizeCanvas();

    window.addEventListener('resize', () => {
      resizeCanvas();
      updatePlayerStats();
      const w = canvas.width / (window.devicePixelRatio||1);
      const h = canvas.height / (window.devicePixelRatio||1);
      if (player.x < player.r) player.x = player.r;
      if (player.x > w - player.r) player.x = w - player.r;
      if (player.y < player.r) player.y = player.r;
      if (player.y > h - player.r) player.y = h - player.r;
    });

    // 슬라이더 UI가 설정창이 켜질 때 마다 항상 맞춰서 보이도록
    function syncSlider() {
      slider.value = Math.round(sensitivity * 100);
      sValue.textContent = slider.value;
    }
    // 설정창 켤 때마다 슬라이더 상태 동기화
    settingsPanel.addEventListener('transitionend', syncSlider);
    settingsBtn.addEventListener('click', syncSlider);
    settingsBtn.addEventListener('touchstart', syncSlider);

  </script>
</body>
</html>
